\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{colortbl}
\usepackage{todonotes}

\usepackage[hidelinks]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan
}

% \usepackage{fancyhdr}
% \usepackage{graphicx}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}

\usepackage{geometry}
\geometry{legalpaper, margin=1in}

\title{VT Good Image Protocol \\
a standardization proposal}
\author{Christian Parpart}
\date{2020-12-13 (draft, revision 0)}

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newcommand{\DA}{\code{DA}}
\newcommand{\DECRQM}[1]{\code{CSI ? #1 \$ p}}
\newcommand{\DECRST}[1]{\code{CSI ? #1 l}}
\newcommand{\DECSET}[1]{\code{CSI ? #1 h}}

\newcommand{\GoodImageProtocol}{\code{Good Image Protocol}}

\begin{document}

\maketitle

\tableofcontents

%\newpage

\section{Motivation} % {{{

For many decades Sixel and ReGIS have been the only image protocols for terminal emulators.
While both are ancient and not even widely implemented, newer generations of people are used
to seeing images and even emojis everywhere.
Those people may eventually touch a virtual terminal emulator and expect to be it no different
than what they are used to in other software systems.

There is growing interest in both of these fields, and thus, many virtual terminal emulator
developers, 30 to 40 years later, have started implementing their own proprietary protocols
for displaying images as Sixel was simply not state of the art anymore.

While this is positive, it also leads to fragmentation in the ecosystem because application
developers do not know what to support in case they intend to display images.
This specification attempts to unify all those image protocols - not as a superset, but rather
as a largest common denominator, with implementation adaptability on both ends - terminal and
application side.

% }}}
\section{Prior art and current state} % {{{

Prior art of image protocols for terminals are as follows:

\subsection{DEC ReGIS graphics}

\begin{itemize}
    \item First appeared in 1981
    \item vector graphics based
    \item implemented by: xterm
\end{itemize}

\subsection{Sixel graphics}

\begin{itemize}
    \item Sixel grpahics first appeared in VT330/VT340 specifications that seems to be published in 1988.
    \item It is pixel based and positions the graphics cursor in a way it is most optimal for dot printers,
        that could print 6 pixels in height per line.
    \item Specialized image format optimized for 6-pin printers.
    \item Supports scrolling the screen if the image does not fit the current screen.
    \item implemented by: xterm, mlterm, wezterm, contour, VTE
\end{itemize}

\subsection{iTerm2 image protocol}

\begin{itemize}
    \item Can associate a file name (Base64 encoded) to the rendered image.
    \item Image display size can be pixel based as well as cell based.
    \item Also has the ability to address the with and hight relative to the terminal window size.
    \item Image data is Base64 encoded.
\end{itemize}

\todo{When was iTerm2 image protocol first introduced?}
\todo{iTerm2 supported image formats?}

\subsection{Terminology image protocol}

\begin{itemize}
    \item First appeared in ... \todo{When did Terminology's image protocol first appear?}
    \item Very hard to find anything out about the underlying transmission protocol.
    \item Seems to be file based.
    \item No specification available.
\end{itemize}

\subsection{Kitty image protocol}

\begin{itemize}
    \item First appeared in 2017
    \item Seperates image upload from image display
    \item Can mandate image sizes in pixels as well as in grid cell dimensions.
    \item Images are rendered independantly of text with a specified Z-axis.
    \item Images can be deleted without knowning their names but only by specifying X/Y/Z axis
          and delete all images intersecting these criteria.
    \item Image formats supported are: RGB, RGBA, PNG.
    \item Image data is Base64 encoded.
    \item Supports optionally compressing the image data.
    \item Supports various image data transmission methods:
        \begin{itemize}
            \item inline, as part of the VT sequence
            \item named shared memory
            \item path to local files
        \end{itemize}
    \item Optionally deletes the local file when requested and the file path is in a secure location.
    \item Hard coded image storage pool to 320 MB (per screen buffer).
\end{itemize}

None of the above image protocols are a good candiate. iTerm2's image protocol is very simple and
can be rendered by specifying grid cell sizes instead of relying on pixels, but lags some
flexibility.

Kitty image protocol on the other hand does provide very good flexibility but is a way too complex which
would hinder broader adoptability and conforming implementations. There is also an added complexity
(such as support for Z-axis) and the ability to send images in a way that does not work trivially
when the terminal is connected to remote clients (such as via SSH). This all seems to hinder
adopting a otherwise very flexible image protocol.

The \GoodImageProtocol specification aims to be future proof with regards to the young generation
of terminal users, as well as simple enough to be widely accepted and adopted on the terminal side
as well as client side, yet allowing future extensions to this protocol
without breaking compatibility to existing implementations.

% }}}
\section{Requirements} % {{{

\begin{enumerate}
    \item \textbf{Deterministic emulation} - The image rendering must not be affected by font size or similar properties.
    \item \textbf{Synchronous operations by default} - No asynchronous operations unless explicitly requested.
    \item \textbf{Remote-terminal capable} - No dependency on the local host, such as the local file system.
    \item \textbf{Preserve aspect ratio by default}
    \item \textbf{Upload and Render seperation} - Image upload must be decoupled from image display
    \item \textbf{Support for rendering tiles of an image} - Adding the ability to only render tiles
        of an image greatly assists client applications when only rendering parts of an image is
        needed (such as in multiplexers).
    \item \textbf{Protocol forward-compatibility} - the protocol must be easily extendable in input
        parameters as well as reusability of the image storage pool
        (such as icon-display, desktop-notifications, background images)
    \item \textbf{Feature detectability} - The image protocl must be easily detectable by well known techniques.
\end{enumerate}

\paragraph*{}

The document at [\ref{ref:twg-gip}] suggests cell based masking for rendering to help rendering more
complex scenes such as in windowed TUI applications or terminal multiplexers with overlaying contents.
However, the same can be achieved with a sequence of Image-Render commands specifying a
sub-rectangle to be rendered of the referenced image.

% }}}
\section{Backwards Compatibility} % {{{

Since all other image protocols are pixel based, the proposed image protocol does not
attempt to retain any backwards compatibility. Instead, the goal is to create
an image protocol that is future proof with todays needs in mind.

% }}}
\section{Future Compatibility and Stability} % {{{

In order to leave room for improvements, the VT sequences should be designed in a way
that allows specifying additional parameters in the future, and simultaneously ensures
that older implementations can still work while safely ignoring any new parameters.

% }}}
\section{Terminal Emulator Requirements} % {{{

This is the list of resource requirements that must be guaranteed by the virtual terminal emulator.

\begin{enumerate}
    \item at least 32 images displayable concurrently
    \item at least 4 MB per image uncompressed
    \item at least 128 MB per storage pool (\(4 * 32\))
\end{enumerate}

Upper limits must be present for security reasons but can be varying by implementation.

\todo{Have the ability to query resource limits?}
\todo{What should happen when the number of images an application wants
      to display is higher than the limit?}

% }}}
\section{Performance Considerations} % {{{

TBD.

% }}}
\section{Security Considerations} % {{{

\begin{itemize}
    \item image upload spamming
    \item huge image Uploads
    \item invalid image Uploads
    \item invalid image render requests (such as out of bounds in offsetted-renders)
\end{itemize}

% }}}
\section{Semantics} % {{{

\subsection{Upload Image}

Uploads an image for future render operations.

\subsubsection*{Parameters}

\begin{itemize}
    \item \textbf{id}; a unique identifier for the uploaded image
    \item \textbf{format}; a value that determines the image format. See section \ref{sec:supported-image-formtats}
    \item \textbf{data}; image data in the given input format
    \item \textbf{width}; optional pixel width of the given image (only required for RGB/RGBA format)
    \item \textbf{height}; optional pixel height of the given image (only required for RGB/RGBA format)
\end{itemize}

\subsubsection{Idempotency}

Image upload can be implemented to be idempotent, i.e. the storage pool keeps an internal hash
of each image that is automatically constructed upon image upload.
If the image was already uploaded, that image's reference count is incremented
and in case it is a named resource, that one will point to that existing one.

\subsubsection{Storage Management}

Uploaded images are reference counted. Uploading a named image will initialize its reference count to 1.

When uploading an image would exceed the storage pool's guarantees,
the host may choose to actively evict older images in either priority:

\begin{enumerate}
    \item oldest first, or
    \item least reference counted (in visible area) first.
\end{enumerate}

Evicted images that were still held in grid cells may display a unicode object replacement
codepoint (U+FFFC) or an empty cell.

Displaying an image results in incrementing the reference counter by the number of grid cells
that are holding parts of the image.

Clearing a grid cell holding an image fragment (e.g. by overwriting or deleting its contents)
will decrement the image reference counter.

When no grid cell is holding a reference to the image,
the corresponding reference counter should be either 1 (if uploaded in a separate step)
or 0 (if uploaded within the render instruction).

Releasing the image by its Id will simply decrement its reference counter.

\subsection{Render Image}

Renders an image that has been previously uploaded.

The image will be rendered with the top-left matching the current ANSI cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{itemize}
    \item \textbf{Id}; unique identifier referencing a previously uploaded image
    \item \textbf{grid-width}; number of grid cells to render horizontally
    \item \textbf{grid-height}; number of grid cells to render vertically
    \item \textbf{resize-policy}; optional, mandates how to resize the image within the grid cells (default NoResize)
    \item \textbf{alignment-policy}; optional, mandates how to align the image within the grid cells (default: MiddleCenter)
    \item \textbf{image-x-offset}; optional, start rendering at the given pixel x-offset cell of the image (default 0)
    \item \textbf{image-y-offset}; optional, start rendering at the given pixel y-offset cell of the image (default 0)
    \item \textbf{image-width}; optional, number of pixels of the image's width to display (default: max width)
    \item \textbf{image-height}; optional, number of pixels of the image's height to display (default max height)
    \item \textbf{status}: optional, request a success/failure status response code from the terminal, by default
        no status result will be sent back to the client application.
        The response status code can be one of the following:
        \begin{itemize}
            \item Success
            \item Image Not Available (has never been or was removed actively or by the garbage collector)
        \end{itemize}
\end{itemize}

% \paragraph*{}
% If parameter \textbf{grid-width} and \textbf{grid-height} are both omitted (or set to 0), then the
% number of grid cells will be automatically determined.

\paragraph*{}
If one of the parameters \textbf{grid-width} and \textbf{grid-height} is present and the other is
missing, the missing one will be automatically determined by preserving the aspect ratio.

\paragraph*{}
Rendered images that produce a padding due to alignment- and resize-policy will fill the gap with the
currently active SGR background color.

\paragraph*{}
Reverse video mode mode (\code{DECSCNM}) will affect the padding color but not the image.

\subsubsection*{Resize Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    NoResize      & Does not perform any resize, leading to a padding on one or two sides \\
                  & as mandated by the alignment-policy. \\
    ResizeToFit   & Resizes the image to fit the specified grid width and height, \\
                  & leading to a padding on zero or one sides as mandated by the alignment-policy. \\
    ResizeToFill  & Resizes the image to fill the specified grid width and height, \\
                  & preserving the aspect ratio, leading to potential clipping depending on the \\
                  & alignment-policy. \\
    StretchToFill & Resizes the image to fill the specified grid width and height, \\
                  & ignoring the aspect ratio, ignoring alignment-policy. \\
    \hline
\end{tabular}

\subsubsection*{Resize Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    TopCenter     & The image is aligned vertically on the top and horizontally in the center of the grid. \\
    TopStart      & The image is aligned vertically on the top and horizontally on the left. \\
    TopEnd        & The image is aligned vertically on the top and horizontally on the right. \\
    \hline
    MiddleCenter  & The image is aligned vertically and horizontally in the center of the grid. \\
    MiddleStart   & The image is aligned vertically centered and horizontally on the left. \\
    MiddleEnd     & The image is aligned vertically centered and horizontally on the right. \\
    \hline
    BottomCenter  & The image is aligned vertically on the bottom and horizontally in the center of the grid. \\
    BottomStart   & The image is aligned vertically on the bottom and horizontally on the left. \\
    BottomEnd     & The image is aligned vertically on the bottom and horizontally on the right. \\
    \hline
\end{tabular}

\subsection{Upload and Render Image}

This uploads and renders the image via a single VT sequence. Therefore no image Id
is required and there won't be any way to reference that image after either.

The parameters of this function is the sum of the image upload and image render parameters excluding the unique
identifier and excluding sub-rectangle rendering parameters.

The image will be rendered with the top-left matching the current ANSI cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{itemize}
    \item \textbf{format}; a value that determines the image format. See section \ref{sec:supported-image-formtats}
    \item \textbf{data}; image data in the given input format
    \item \textbf{image-width}; optional, number of pixels of the image's width to display (default: max width)
    \item \textbf{image-height}; optional, number of pixels of the image's height to display (default max height)
    \item \textbf{resize-policy}; optional, mandates how to resize the image within the grid cells (default NoResize)
    \item \textbf{alignment-policy}; optional, mandates how to align the image within the grid cells (default: MiddleCenter)
    \item \textbf{grid-width}; number of grid cells to render horizontally
    \item \textbf{grid-height}; number of grid cells to render vertically
\end{itemize}

\todo{Specify how auto-scroll can be achieved in primary screen for Render and Upload-and-Render actions.}

\subsection{Release Image}

Removes the mapping from unique Id to the image in a storage pool.

This will cause decrementing the use-count of the previously uploaded image.

\subsubsection*{Parameters}

\begin{itemize}
    \item \textbf{id}; Unique identifier referencing a previously uploaded image.
\end{itemize}

\subsection{Feature Detection}

\DA is already used to advertise terminal features, including sixel graphics, and thus,
it does make sense to be used to also advertise the availability of \GoodImageProtocol.

There is some improved feature detection specification work ongoing,
so there may be other ways to detect \GoodImageProtocol in the future, when that is ready.

\subsection{Interoperability with other VT sequences}

\subsubsection*{Clearing the screen}

VT sequences (such as \code{CSI Ps J}) that reset at least the textual contents of the grid cells will also
clear their image fragment referencing an underlying image, possibly also releasing the
underlying image(s) from the image storage pool when their reference count goes down to zero.

\subsubsection*{Primary and alternate screen}

Alternate screen and primary screen maintain both their own image storage pool.

When leaving the alternate screen, its image storage pool gets cleared too.
% }}}
\section{Syntax} % {{{

This section maps each semantic action to actual VT sequences.

\subsection{DCS Message Format}

TODO: describe the Message format here.

\subsection{Upload Image}

Syntax: \code{DCS u <named parameters> ST}

The payload's format is mandated by the \code{fmt}'s value. However, since it must not contain
any C0 or C1 escape codes, the transport is further protected by encoding it via Base64.

\subsubsection*{Named Parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter}   & description \\
    \hline
    fmt         & enum (see section \ref{sec:supported-image-formtats}) \\
    width       & number of image width of the uploaded image (not needed for PNG) \\
    height      & number of image height of the uploaded image (not needed for PNG) \\
    n           & unique name of the image \\
    p           & Base64 encoded image data \\
    \hline
\end{tabular}

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to upload an image:
    function send_image() {
        local ImageId=$(echo -ne "org.binutils.ls.$1" | base64 -)
        local ImageData=$(base64 "$2")
        local ImageFormat=3 # 3=PNG
        echo -ne "\033Puf=${ImageFormat},n=${ImageId};!${ImageData}\033\\"
    }
\end{verbatim}

\subsection{Render Image}

Syntax: \code{DCS r <named parameters> ST}

\subsubsection*{Named parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter}   & \textbf{Value} \\
    \hline
    name        & image Id as string \\
    c           & number of columns this image will be printed on \\
    r           & number of rows the image will be printed on \\
    x           & x-offset into the referenced image in screen coordinates \\
    y           & y-offset into the referenced image in screen coordinates \\
    w           & width of the referenced image in screen coordinates \\
    h           & height of the referenced image in screen coordinates \\
    z           & resize policy (default: 2), one of: \\ % TODO: defaults should have the lowest value (=> 1)
                & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    a           & alignment policy (default: 1), one of: \\
                & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
                & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
                & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    s           & optionally request a status whether the image was been rendered \\
                & default is no response will be sent, values are one of: \\
                & 0 (Success), 1 (Image not available) \\
    \hline
\end{tabular}

\subsubsection*{Response Sequence}

When a response status code was requested, the syntax will be as follows:

\begin{tabular}{ |r|l| }
    \hline
    \textbf{VT sequence} & \textbf{description} \\
    \hline
    \code{CSI > 0 i} & Image is rendered successfully \\
    \code{CSI > 1 i} & Image was not rendered. No image with the given Id found. \\
    \hline
\end{tabular}

\subsubsection*{Example}

\begin{verbatim}
    # Shell function demonstrating how to render an image:
    function render_image() {
        # Rendering the given PNG image at the current cursor position with a 20x10 size.
        local ImageId=$(echo -ne "org.binutils.ls.$1" | base64 -)
        local GridWidth="20"
        local GridHeight="10"
        echo -ne "\033P1:${GridWidth};2:${GridHeight}rid=${ImageId}\033\\"
    }
\end{verbatim}

\subsection{Upload and Render Image}

Syntax: \code{DCS <numerical parameters> s <payload> ST}

\subsubsection*{Numerical parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter}   & \textbf{Key} & \textbf{Value} \\
    \hline
    fmt         & 1   & enum (see section \ref{sec:supported-image-formtats}) \\
    grid-width  & 2   & UInt32 \\
    grid-height & 3   & UInt32 \\
    image-width & 4   & UInt32 \\
    image-height& 5   & UInt32 \\
    resize      & 6   & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    alignment   & 7   & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
                &     & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
                &     & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    \hline
\end{tabular}

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to render a oneshot image:
    function send_image_once() {
        local ImageData=$(base64 "$1")
        local ImageFormat=3 # 3=PNG
        local GridWidth="20"
        local GridHeight="10"
        echo -ne "\033P1:${ImageFormat};2:${GridWidth};3:${GridHeight}s${ImageData}\033\\"
    }
\end{verbatim}

\subsection{Release Image}

Syntax: \code{DCS d <named parameters> ST}

\subsubsection*{Named Parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter}   & \textbf{Value} \\
    \hline
    Id          & String \\
    \hline
\end{tabular}

\subsection{Feature Detection}

Syntax: \DA

\DA's response code for detecting support for an implementation of this specification is \code{11}.

% }}}
\section{Support Image Formats} % {{{

\label{sec:supported-image-formtats}

\begin{tabular}{c | c | l}
    File Format & Identifier & Description \\ \hline
    RGB & 1 & raw RGB data with each color component being of size 1 byte. \\
    RGBA & 2 & raw RGBA data, just like RGB, but with an alpha channel. \\
    PNG & 3 & PNG file format \\
\end{tabular}

% }}}
\section{References} % {{{

\begin{enumerate}
    \item \label{ref:ctlseqs}\url{https://invisible-island.net/xterm/ctlseqs/ctlseqs.txt}
    \item \label{ref:twg-simple-image-display}Simple Image display, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/12}
    \item \label{ref:twg-gip}Good Image Protocol, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/26}
    \item \label{ref:image-sixel}Sixel Image Protocol, \url{https://vt100.net/docs/vt3xx-gp/chapter14.html}
    \item \label{ref:image-item2}iTerm2's image protocol, \url{https://iterm2.com/documentation-images.html}
    \item \label{ref:image-terminology}Terminology's image protocol, \url{https://www.enlightenment.org/docs/apps/terminology.md} \todo{Terminology image protocol spec not found. ;-(}
    \item \label{ref:image-kitty}Kitty's image protocol, \url{https://sw.kovidgoyal.net/kitty/graphics-protocol.html}
\end{enumerate}
% }}}

\section{Editorial Notes}

\begin{itemize}
    \item Maybe use tables instead of lists for parameter listings?
    \item $0x3A$ \code{:} is not allowed in DCS, check that. Maybe all params should be name-based then ...
    \item Should we mention how to deal with HiDPI displays and content scaling?
\end{itemize}

\listoftodos

\end{document}

% vim:ts=4:sw=4
