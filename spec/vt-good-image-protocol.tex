% vim:cc=80:cole=0
\documentclass[a4paper]{article}
%\documentclass[a4paper, 20pt]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{colortbl}
\usepackage{todonotes}

\usepackage[hidelinks]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan
}

% \usepackage{fancyhdr}
% \usepackage{graphicx}

\usepackage{draftwatermark}
\SetWatermarkText{Draft}
\SetWatermarkScale{4}

\usepackage[english]{babel}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}

\usepackage{geometry}
\geometry{legalpaper, margin=1in}

\title{VT Good Image Protocol \\
a standardization proposal}
\author{Christian Parpart}
% \date{2020-12-18 (draft, revision 0)}
\date{\today \quad (draft, revision 0)}

\newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newcommand{\DA}{\code{DA1}}
\newcommand{\DECRQM}[1]{\code{CSI ? #1 \$ p}}
\newcommand{\DECRST}[1]{\code{CSI ? #1 l}}
\newcommand{\DECSET}[1]{\code{CSI ? #1 h}}

\newcommand{\GoodImageProtocol}{\code{Good Image Protocol}}

\begin{document}

\maketitle

\tableofcontents

%\newpage

\section{Motivation} % {{{

For many decades Sixel and ReGIS have been the only image protocols for terminal emulators.
While both are ancient and not even widely implemented, newer generations of people are used
to seeing images and even emoji everywhere.
Those people may eventually touch a virtual terminal emulator and expect it to be no different
than what they are used to from other software systems.
\todo{What about Tektronix?}

There is a growing interest in displaying images in todays
virtual terminal emulators.

Since these protocols are were not designed with todays needs in mind,
virtual terminal emulator developers have started implementing their own
proprietary protocols for displaying images as Sixel and related
were simply not state of the art anymore.

While this is positive, it also leads to fragmentation in the ecosystem
because application developers do not know what to support in case they intend
to display images in their client applications, and even new terminal emulator
developers don't know what protocol to implement.

There is also a recent resurrection of the Sixel bitmap protocol
to be implemented by some terminal emulator
\footnote{Alacritty, Contour, gnome-terminal, iTerm2, wezterm, xterm.js}
and library \footnote{notcurses} developers,
however, none of them is 100\% conforming to how Sixel used to work 50 years ago,
as there is no easy way to access the hardware they were implemented on
and also xterm does not implement every aspect of Sixel.

This specification attempts to unify all those image protocols and addresses
some of the issues, not as a superset, but rather as a largest common denominator,
with usability, simplicity, and implementation adaptability in mind and
is also an attempt to formalize what was written down in \ref{ref:twg-gip},
which can be seen as a conclusion of many discussions that happened scattered
across different forums on the topic of a future image protocol.

% }}}
\section{Terminology} % {{{
\begin{itemize}
    \item \textbf{screen cell}; a rectanglular area of the screen that can contain a character with
        its graphics rendition or an image fragment
    \item \textbf{image fragment}; a rectanglular tile of an image that perfectly fits into a screen cell
    \item \textbf{image storage pool}; a backing store for images received for future operations
\end{itemize}

\todo{more terminology to add?}

% }}}
\section{Prior art and current state} % {{{

Prior art of image protocols for terminals are as follows:

\subsection{Tektronix}

\begin{itemize}
    \item First appeared in 1970s
    \item Tektronix 4010 series was a family of text-and-graphics computer terminals based on storage-tube technology created by Tektronix.
\end{itemize}

\subsection{DEC ReGIS graphics}

\begin{itemize}
    \item First appeared in VT125, in July 1981
    \item vector graphics based
    \item implemented by: xterm
\end{itemize}

\subsection{Sixel graphics}

\begin{itemize}
    \item Sixel grpahics first appeared in LA50 dot-matrix printers (1983) and short after in the VT240 in Oktober 1983.
    \item It is pixel based and positions the graphics cursor in a way it is most optimal for dot printers,
        that could print 6 pixels in height per line.
    \item Specialized image format optimized for 6-pin printers.
    \item Supports scrolling the screen if the image does not fit the current screen.
    \item implemented by: xterm, mlterm, wezterm, contour, VTE
\end{itemize}

This protocol only understands pixels and thus is dependant on the
configured font size and screen resolution of the terminal, which
terminal emulators seem to have solved differently and therefore cannot
be relied on.

\subsection{Terminology image protocol}

Terminology's image protocol is rather a media transport protocol as it
can also be used to render animations, including videos.

\begin{itemize}
    \item First appeared in June, 2012.
    \item Uses VT sequences inspired by Xterm's sequence extensions.
    \item Specification is in the source code repository's \texttt{README.md} file.
\end{itemize}

\subsection{iTerm2 image protocol}

\begin{itemize}
    \item First introduced in 2014 with documentation added in 2015.
    \item Can associate a file name (Base64 encoded) to the rendered image.
    \item Image display size can be pixel based as well as cell based.
    \item Also has the ability to address the width and height relative to the terminal window size.
    \item Image data is Base64 encoded.
    \item Any image format that macOS supports will are supported by iTerm2's image protocol,
        including PDF, PICT, EPS, or any number of bitmap data formats (PNG, GIF, etc.).
\end{itemize}

The dependency on macOS for supported image formats makes it a little blurry
specification also.

\subsection{DomTerm's inline image support}

\begin{itemize}
    \item DomTerm's image support appeared in 2016.
    \item No explicit image protocol but a "insert HTML"-protocol that does support images.
    \item Specification is in the source code repository's \texttt{README.md} file.
\end{itemize}

The typical way to insert an image is to insert an HTML <img> element,
with the src attribute using a data: URL scheme,
with the actual data inline as base64.

Any image format supported by the underlying browser engine is allowed.

The \texttt{<img>} element can contain attributes such as width, height, alt
and options to add scrollbars.

The tight integration to the browser makes it hard to be adopted by native
terminals.
\subsection{Kitty image protocol}

\begin{itemize}
    \item First appeared in 2017
    \item Seperates image upload from image display
    \item Can mandate image sizes in pixels as well as in screen cell dimensions.
    \item Images are rendered independantly of text with a specified Z-axis.
    \item Images can be deleted without knowning their names but only by specifying X/Y/Z axis
          and delete all images intersecting these criteria.
    \item Image formats supported are: RGB, RGBA, PNG.
    \item Image data is Base64 encoded.
    \item Supports optionally compressing the image data.
    \item Supports various image data transmission methods:
        \begin{itemize}
            \item inline, as part of the VT sequence
            \item named shared memory
            \item path to local files
        \end{itemize}
    \item Optionally deletes the local file when requested and the file path is in a secure location.
    \item Hard coded image storage pool to 320 MB (per screen buffer).
\end{itemize}

None of the above image protocols are a good candiate. iTerm2's image protocol is very simple and
can be rendered by specifying screen cell sizes instead of relying on pixels, but lacks some
flexibility.

Kitty image protocol on the other hand does provide very good flexibility but is way too complex which
would hinder broader adoptability and conforming implementations, potentially leading to partial
implementations and thus fragmentation.
There is also an added complexity (such as support for Z-axis) and the ability
to send images in a way that does not work trivially when the terminal is
connected to remote clients (such as via SSH). This all seems to hinder
adopting a otherwise very flexible image protocol.

The \GoodImageProtocol specification aims to be future proof with regards to
the young generation of terminal users, as well as being simple enough
to be widely accepted and adopted on the terminal side as well as client side,
yet allowing future extensions to this protocol
without breaking compatibility to existing implementations.

% }}}
\section{Requirements} % {{{

\begin{enumerate}
    \item \textbf{Deterministic emulation} - The image rendering must not be affected by font size
        or similar properties nor on external API to make productive use of this protocol.
    \item \textbf{Synchronous operations by default} - No asynchronous operations unless explicitly requested.
    \item \textbf{Remote-terminal capable} - No dependency on the local host, such as the local file system.
    \item \textbf{Preserve aspect ratio by default}
    \item \textbf{Upload and Render seperation} - Image upload must be decoupled from image display
    \item \textbf{Support for rendering tiles of an image} - Adding the ability to only render tiles
        of an image greatly assists client applications when only rendering parts of an image is
        needed (such as in multiplexers).
    \item \textbf{Protocol forward-compatibility} - the protocol must be easily extendable in input
        parameters as well as reusability of the image storage pool
        (such as icon-display, desktop-notifications, background images)
    \item \textbf{Feature detectability} - The image protocl must be easily detectable by well known techniques.
\end{enumerate}

\paragraph*{}

The document at [\ref{ref:twg-gip}] suggests cell based masking for rendering to help rendering more
complex scenes such as in windowed TUI applications or terminal multiplexers with overlaying contents.
However, the same can be achieved with a sequence of Image-Render commands specifying a
sub-rectangle to be rendered of the referenced image.

% }}}
\section{Backwards Compatibility} % {{{

Since all other image protocols are pixel based, the proposed image protocol does not
attempt to retain any backwards compatibility. Instead, the goal is to create
an image protocol that is future proof with todays needs in mind.

% }}}
\section{Future Compatibility and Stability} % {{{

In order to leave room for improvements, the VT sequences should be designed in a way
that allows specifying additional parameters in the future, and simultaneously ensures
that older implementations can still work while safely ignoring any new parameters.

% }}}
\section{Terminal Emulator Requirements} % {{{

This is the list of resource requirements that must be guaranteed
by the virtual terminal emulator.

\begin{enumerate}
    \item at least 64 images concurrently
    \item at least 4 MB per image uncompressed (RGBA8888)
\end{enumerate}

Upper limits must be present for security reasons but can be varying by implementation.

% }}}
\section{Performance Considerations} % {{{

TBD.

% }}}
\section{Security Considerations} % {{{

\begin{itemize}
    \item image upload spamming - should be avoidable by a meaningful limit
        on how many images can be uploaded at the same time.
        Exceeding the limit will result in evicting older images in FIFO order,
        leading to dangling image fragments, as their related image has been
        evicted. A placeholder or an empty screen cell will be displayed instead.
    \item huge image uploads - should be avoidable by limiting the number
        of pixels an image can take.
    \item invalid image uploads - a terminal proxy (such as tmux) do not
        implicitly need to validate image formats as they are usually just
        forwarding the blobs to the connected terminal. A non-proxying
        terminal however will validate implicitly by loading the specified
        file format.
    \item invalid image render requests (such as out of bounds in offsetted-renders) -
        invalid named images will just not be displayed.
        Overextending dimensions will be displayed but result in cut-of images.
\end{itemize}

% }}}
\section{Semantics} % {{{
\subsection{Feature Detection} % {{{

\DA is already used to advertise terminal features, including Sixel graphics, and thus,
\DA is also used to advertise \GoodImageProtocol support, for consistency.

There is some improved feature detection specification work ongoing,
so there may be other ways to detect \GoodImageProtocol in the future, when that is ready.

% }}}
\subsection{Querying Resource Limits} % {{{

Resource limits must be queryable whilest the requirements must be met.
Every resource requirement also has a limit at exactly
the value of the requirement or above, and must be queryable

\begin{itemize}
    \item number of images displayable concurrently (visible or not visible)
        A recommendation for this limit would be 128 on terminals running on desktop computers.
    \item number of uncompressed pixels (RGBA8888) an a single image can take at most.
        A recommendation for this limit would be 8 MB on terminals running on desktop computers.
\end{itemize}

% }}}
\subsection{Upload Image} % {{{

Uploads an image for future render operations.

\subsubsection*{Parameters}

\begin{tabular}{|l|l|l|}
  \hline
  \textbf{parameter name} & \textbf{description} \\
  \hline
  \textbf{name}           & a unique identifier for the uploaded image \\
  \textbf{format}         & a value that determines the image format. \\
                          & See section \ref{sec:supported-image-formtats} for available image formats \\
  \textbf{width}          & optional pixel width of the given image
                            (only required if this information is not provided
                            inline via the \textbf{data} field) \\
  \textbf{height}         & optional pixel height of the given image
                            (only required if this information is not provided
                            inline via the \textbf{data} field) \\
  \textbf{data}           & image data in the specified input format \\
  \hline
\end{tabular}

\subsubsection{Idempotency}

Image upload can be implemented to be idempotent, but don't have to,
i.e. the storage pool keeps an internal hash of each image that is
automatically constructed upon image upload.

If the image was already uploaded, that image's reference count is incremented
and in case it is a named resource, that one will point to that existing one.

% }}}
\subsection{Render Image} % {{{

Renders an image that has been previously uploaded.
The image will be rendered with the top-left matching the current ANSI cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{tabular}{|l|l|l|}
    \hline
    \textbf{parameter name} & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{name} &           & unique identifier referencing a previously uploaded image \\
    \textbf{screen-rows} &    & number of screen cells to render horizontally \\
    \textbf{screen-cols} &    & number of screen cells to render vertically \\
    \textbf{resize-policy} & NoResize & optional, mandates how to resize the image within the screen cells \\
    \textbf{alignment-policy} & MiddleCenter & optional, mandates how to align the image within the screen cells \\
    \textbf{image-x-offset} & 0 & start rendering at the given pixel x-offset cell of the image \\
    \textbf{image-y-offset} & 0 & start rendering at the given pixel y-offset cell of the image \\
    \textbf{image-width}    & screen-rows & optional, number of pixels of the image's width to display \\
    \textbf{image-height}   & screen-cols & number of pixels of the image's height to display \\
    \textbf{static-cursor}  & false & optional, tells the terminal to not move the cursor after having the image rendered \\
    \textbf{status}         & false & request a success/failure status response code from the terminal \\
        & & If value is true, a response is sent back to the application \\
        & & to indicate success or failure. \\
        & & If value is set to false (or parameter is not present), \\
        & & no response is sent back to the application. \\
    \hline
\end{tabular}

% \paragraph*{}
% If parameter \textbf{screen-width} and \textbf{screen-height} are both omitted (or set to 0), then the
% number of screen cells will be automatically determined.

\paragraph*{}
If one of the parameters \textbf{screen-width} and \textbf{screen-height} is present and the other is
missing, the missing one will be automatically determined by preserving the aspect ratio.

\paragraph*{}
Rendered images that produce a padding due to alignment- and resize-policy will fill the gap with the
currently active SGR background color.

\paragraph*{}
Reverse video mode mode (\code{DECSCNM}) will affect the padding color but not the image.

\subsubsection*{Resize Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    NoResize      & Does not perform any resize, leading to a padding on one or two sides \\
                  & as mandated by the alignment-policy. \\
    ResizeToFit   & Resizes the image to fit the specified screen width and height, \\
                  & leading to a padding on zero or one sides as mandated by the alignment-policy. \\
    ResizeToFill  & Resizes the image to fill the specified screen width and height, \\
                  & preserving the aspect ratio, leading to potential clipping depending on the \\
                  & alignment-policy. \\
    StretchToFill & Resizes the image to fill the specified screen width and height, \\
                  & ignoring the aspect ratio, ignoring alignment-policy. \\
    \hline
\end{tabular}

\subsubsection*{Alignment Policy}

\begin{tabular}{ |l|l| }
    \hline
    \textbf{Name}          & \textbf{Description} \\
    \hline
    TopCenter     & The image is aligned vertically on the top and horizontally in the center of the screen. \\
    TopStart      & The image is aligned vertically on the top and horizontally on the left. \\
    TopEnd        & The image is aligned vertically on the top and horizontally on the right. \\
    \hline
    MiddleCenter  & The image is aligned vertically and horizontally in the center of the screen. \\
    MiddleStart   & The image is aligned vertically centered and horizontally on the left. \\
    MiddleEnd     & The image is aligned vertically centered and horizontally on the right. \\
    \hline
    BottomCenter  & The image is aligned vertically on the bottom and horizontally in the center of
    the screen. \\
    BottomStart   & The image is aligned vertically on the bottom and horizontally on the left. \\
    BottomEnd     & The image is aligned vertically on the bottom and horizontally on the right. \\
    \hline
\end{tabular}

% }}}
\subsection{Upload and Render Image} % {{{

This uploads and renders the image via a single VT sequence. Therefore no image Id
is required and there won't be any way to reference that image after either.

The parameters of this function is the sum of the image upload and image render parameters excluding the unique
identifier and excluding sub-rectangle rendering parameters.

The image will be rendered with the top-left matching the current ANSI cursor position.
The cursor will not be moved by this operation.

\subsubsection*{Parameters}

\begin{tabular}{|l|l|l|}
    \hline
    \textbf{parameter name} & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{format} & & a value that determines the image format. See section \ref{sec:supported-image-formtats} \\
    \textbf{data} & & image data in the given input format \\
    \textbf{image-width} & 0 & number of pixels of the image's width to display \\
    \textbf{image-height} & 0 & number of pixels of the image's height to display \\
    \textbf{resize-policy} & NoResize & mandates how to resize the image within the screen cells \\
    \textbf{alignment-policy} & MiddleCenter & mandates how to align the image within the screen cells \\
    \textbf{screen-width} & & number of screen cells to render horizontally \\
    \textbf{screen-height} & & number of screen cells to render vertically \\
    \textbf{auto-scroll} & & boolean, indicating whether or not the page is beign scrolled up \\
            & & if the image would not fit otherwise \\
    \hline
\end{tabular}

\todo{Specify how auto-scroll can be achieved in primary screen for Render and Upload-and-Render actions.}
\todo{Should auto-scroll be only possible in primary screen?}

% }}}
\subsection{Release Image} % {{{

Removes the mapping of the name to the image in a storage pool.
This will cause decrementing the use-count of the previously uploaded image.
Existing rendered images are not affected by this operation.

\subsubsection*{Parameters}

\begin{tabular}{|l|l|l|}
    \hline
    \textbf{parameter name} & \textbf{default} & \textbf{description} \\
    \hline
    \textbf{name}       & & a unique identifier of the uploaded image \\
    \hline
\end{tabular}

% }}}
\subsection{Storage Management} % {{{

Uploaded images are reference counted.
Uploading a named image will associate the uploaded image with the specified
name and initialize the image's reference count to 1.

When uploading an image would exceed the storage pool's guarantees,
the host may choose to actively evict images in FIFO-order until the new image fits.

If the image is larger than the allowed storage size, the upload will fail.

Evicted images that were still held in screen cells will
either display a image placeholder or an empty screen cell.

Displaying an image results in incrementing the reference counter
by the number of screen cells that are holding fragments of the image.

Clearing a screen cell holding an image fragment (e.g. by overwriting
or deleting its contents) will decrement the image reference count of
the prior referenced image.

When no screen cell is holding a reference to the image,
the corresponding reference counter should be either 1 (if uploaded in a separate step)
or 0 (if uploaded within the render instruction).
% ^^^ does this make sense to be mentioned here?
% a named image upload initializes the blob ref count to 1 (for the named reference)
% whereas the blob also has a refcount of 1 when oneshotting,
% because the one reference comes from the image-display action.

Releasing the image by its name will remove the name-to-image association, and thus,
decrement its reference counter.

Uploading a new image with an already used name will first release the old name-to-image association
as mentioned earlier and then register the new image with its name. This will not cause
any visible side effects - existing image fragments to the old image will not be touched.


% }}}
\subsection{Interoperability with other VT sequences} % {{{

Text and images are mutually exclusive objects, and therefore,
a screen cell either holds text or an image, but not both.

This property makes image cells compatible to all cell operational VT sequences.

\subsubsection*{Screen cell characters and image tiles}

Image fragments and characters in a screen cell are mutually exclusive.
Therefore, when an image is being rendered into a screen cell,
it is replacing textual information.

Analogous, when a character is placed into a screen cell that previously
contained an image fragment, this image fragment is being replaced by the
character.

\subsubsection*{Image alpha channel and graphics rendition background color}

Images with an alpha channel will blend into the graphics renditions
background color (respecting reverse-video attribute) of that cell analogous
to how padding pixel color is applied for image fragments.

\subsubsection*{Hyperlinks}

If the terminal emulator supports hyperlinks and the application has initiated
a hyperlink, followed by rendering an image, the whole rendered image becomes
hyperlinked, analogous to how hyperlinks are applied to text.

\subsubsection*{Text reflow}

Text reflow is supported only inconsistently across a few terminals. Therefore this
specification does not attempt to address this for images.
Therefore image cells behave just like text cells,
potentially wrapping on shrink and eventually merging back when regrown.

When text reflow is going to be formally specified it must then also address images.

\subsubsection*{Clearing the screen}

VT sequences (such as \code{CSI Ps J}) that reset at least the textual contents
of the screen cells will, because of the mutual exclusion stated above, also
clear their image fragment referencing an underlying image,
possibly also releasing the underlying image(s) from the image storage pool
when their reference count has reached zero.

\subsubsection*{Primary and alternate screen}

Alternate screen and primary screen maintain both a shared image storage pool.

When leaving the alternate screen, all image cells are getting cleared at the
same time in order to reduce resource pressure at the earliest point possible.

This is different from text and SGR attributes, which will be cleared when
entering the alternate buffer.

% }}}

% }}}
\section{Syntax} % {{{

This section maps each semantic action to actual VT sequences.

\subsection{DCS Message Format} % {{{

\todo{Many people prefer OSC over DCS due to ancient terminal emulators}
\todo{message format spec}

TBD. Describe the Message format here that is being implemented in MessageParser.\{h,cpp\}.

\begin{itemize}
    \item inspired by HTTP message protocol
    \item optional sequence of headers and an optional body
    \item header is a name and a value, delimited by equal symbol \code{=}
    \item header sequence is delimited by comma symbol \code{,}
    \item header sequence and body is delimited by semicolon \code{;}
    \item header value and body can be base64 encoded by prepending \\
        an exclamation mark at the beginning of the header's value or body.
    \item superfluous commas in header seperation are ignored
    \item header names without a value reflect a boolean truth value
\end{itemize}

\todo{Do we want to support multiple transport encodings while defaulting to Base64 if encoded?}

% }}}
\subsection{Upload Image} % {{{

Syntax: \code{DCS u <message> ST}

The payload's format is mandated by the \code{fmt}'s value. However, since it must not contain
any C0 or C1 escape codes, the transport is further protected by encoding it via Base64.

\subsubsection*{Parameters}

\begin{tabular}{ |l|l|l| }
    \hline
    \textbf{header name}   & \textbf{title}   & \textbf{notes} \\
    \hline
    \textbf{f}       & format & enum (see section \ref{sec:supported-image-formtats}) \\
    \textbf{w}       & width & number of image width of the uploaded image (not needed for PNG) \\
    \textbf{h}       & height & number of image height of the uploaded image (not needed for PNG) \\
    \textbf{n}       & name & unique name of the image \\
    \hline
\end{tabular}

The message body contains the image data.

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to upload an image:
    function send_image() {
        local ImageId=$(echo -ne "org.binutils.ls.$1" | base64 -)
        local ImageData=$(base64 "$2")
        local ImageFormat=3 # 3=PNG
        echo -ne "\033Puf=${ImageFormat},n=${ImageId};!${ImageData}\033\\"
    }
\end{verbatim}

\pagebreak

% }}}
\subsection{Render Image} % {{{

Syntax: \code{DCS r <message> ST}

\subsubsection*{Message parameters}

\begin{tabular}{ |r|l|l| }
    \hline
    \textbf{message header}   & \textbf{title}   & \textbf{Value} \\
    \hline
    n & name            & image Id as string \\
    c & screen-cols     & number of columns this image will be printed on \\
    r & screen-rows     & number of rows the image will be printed on \\
    x & image-x-offset  & x-offset into the referenced image in screen coordinates \\
    y & image-x-offset  & y-offset into the referenced image in screen coordinates \\
    w & image-width     & width of the referenced image in screen coordinates \\
    h & image-height    & height of the referenced image in screen coordinates \\
    z & resize-policy   & one of: \\ % TODO: defaults should have the lowest value (=> 1)
      &                 & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    a & alignment-policy & one of: \\
      &                 & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
      &                 & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
      &                 & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    t & static-cursor   & boolean indicating to not move the cursor \\
    s & status          & one of: 1 (request status response), 0 otherwise \\
    \hline
\end{tabular}

\subsubsection*{Response Sequence}

When a response status code was requested, the syntax will be as follows:

\begin{tabular}{ |r|l| }
    \hline
    \textbf{VT sequence} & \textbf{description} \\
    \hline
    \code{CSI > 0 i} & Image is rendered successfully \\
    \code{CSI > 1 i} & Image was not rendered. No image with the given Id found. \\
    \hline
\end{tabular}

\subsubsection*{Example}

\begin{verbatim}
    # Shell function demonstrating how to render an image:
    function render_image() {
        # Rendering the given PNG image at the current cursor position with a 20x10 size.
        local ImageId=$(echo -ne "org.binutils.ls.$1" | base64 -)
        local ScreenWidth="20"
        local ScreenHeight="10"
        echo -ne "\033P1:${ScreenWidth};2:${ScreenHeight}rid=${ImageId}\033\\"
    }
\end{verbatim}

% }}}
\subsection{Upload and Render Image} % {{{

Syntax: \code{DCS <numerical parameters> s <payload> ST}

\subsubsection*{Numerical parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter name}   & \textbf{Key} & \textbf{Value} \\
    \hline
    fmt         & 1   & enum (see section \ref{sec:supported-image-formtats}) \\
    screen-width  & 2   & UInt32 \\
    screen-height & 3   & UInt32 \\
    image-width & 4   & UInt32 \\
    image-height& 5   & UInt32 \\
    resize      & 6   & 1 (NoResize), 2 (ResizeToFit), 3 (ResizeToFill), 4 (StretchToFill) \\
    alignment   & 7   & 1 (MiddleCenter), 2 (MiddleStart), 3 (MiddleEnd), \\
                &     & 4 (TopStart), 5 (TopCenter), 6 (TopEnd), \\
                &     & 7 (BottomStart), 8 (BottomCenter), 9 (BottomEnd) \\
    \hline
\end{tabular}

\subsubsection*{Example}

This is a small Bash shell example that is uploading a PNG image with a fixed ID.

\begin{verbatim}
    # Shell function demonstrating how to render a oneshot image:
    function send_image_once() {
        local ImageData=$(base64 "$1")
        local ImageFormat=3 # 3=PNG
        local GridWidth="20"
        local GridHeight="10"
        echo -ne "\033P1:${ImageFormat};2:${GridWidth};3:${GridHeight}s${ImageData}\033\\"
    }
\end{verbatim}

% }}}
\subsection{Release Image} % {{{

Syntax: \code{DCS d <message> ST}

\subsubsection*{Message parameters}

\begin{tabular}{ |c|c|l| }
    \hline
    \textbf{parameter name}   & \textbf{Value} \\
    \hline
    Id          & String \\
    \hline
\end{tabular}

% }}}
\subsection{Feature Detection} % {{{

Syntax: \DA

\DA's response code for detecting support for an implementation of this specification is \code{11}.

% }}}
% }}}
\section{Supported Image Formats} % {{{

\label{sec:supported-image-formtats}

\begin{tabular}{c | c | l}
    File Format & Identifier & Description \\ \hline
    RGB         & 1          & raw RGB data with each color component being of size 1 byte. \\
    RGBA        & 2          & raw RGBA data, just like RGB, but with an alpha channel. \\
    PNG         & 3          & PNG file format \\
\end{tabular}

\todo{I think it make sense to use mimetype as values instead?}

% }}}
\section{Future Modifications} % {{{

Possible future modifications could (but do not have to) cover:

\begin{itemize}
    \item Set and reset resource limits.
    \item Query allocated resource names.
    \item Query resource utilization.
    \item Direct support of animations.
    \item Different transport encodings (other than Base64).
    \item Extending the use of uploaded images to also be used for application / window / tab icons.
    \item Extending the use of uploaded images to terminal background.
    \item Extending Image-Render with a z-axis to optional render on top or below text.
\end{itemize}

% }}}
\section{References} % {{{

\begin{enumerate}
    \item \label{ref:ctlseqs}\url{https://invisible-island.net/xterm/ctlseqs/ctlseqs.txt}
    \item \label{ref:twg-simple-image-display}Simple Image display, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/12}
    \item \label{ref:twg-gip}Good Image Protocol, \url{https://gitlab.freedesktop.org/terminal-wg/specifications/-/issues/26}
    \item \label{ref:image-sixel}Sixel Image Protocol, \url{https://vt100.net/docs/vt3xx-gp/chapter14.html}
    \item \label{ref:image-item2}iTerm2's image protocol, \url{https://iterm2.com/documentation-images.html}
    \item \label{ref:image-terminology}Terminology's image protocol, \url{https://github.com/borisfaure/terminology/blob/master/README.md#available-commands}
    \item \label{ref:image-kitty}Kitty's image protocol, \url{https://sw.kovidgoyal.net/kitty/graphics-protocol.html}
\end{enumerate}

% }}}
\section{Editorial Notes} % {{{

\begin{itemize}
    \item Maybe use tables instead of lists for parameter listings?
    \item Should we mention how to deal with HiDPI displays and content scaling?
    \item How to implement a cat-like tool for images without breaking determinism for proxy
        terminals (like tmux).
        I.e. how does the proxy terminal know about how many rows will be used when
        a pixel perfect rendering is attempted (resize-policy set to NoResize,
        screen-cols=\$COLUMNS). But what is row count?
        I think the only way to achieve that if that image-cat tool peaks into
        the image dimensions and calculates a maybe perfect number of rows
        based on that and the retrieved pixel height (which is not recommended though).
    \item Do we want to deal with transparent pixels differently?
    \item Is it \textbf{really} necessary to be able to render above/below text with preserving the
        text? What is the real use case for that? (that would require the introduction of a z-axis).
    \item If so, can images be layered, therefore can a cell have more than one image.
        And what is happening if the above image is removed. Will the image below be shown?
    \item Should SGRs be usable in screen cells showing image fragments?
\end{itemize}

% }}}

\listoftodos

\end{document}

% vim:ts=4:sw=4
